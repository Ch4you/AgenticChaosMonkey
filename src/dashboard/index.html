<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Agent Chaos Dashboard - Real-Time Visualization</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0b1020;
            color: #e5e7eb;
            overflow-x: hidden;
        }
        
        .header {
            position: sticky;
            top: 0;
            z-index: 10;
            background: rgba(16, 23, 42, 0.96);
            backdrop-filter: blur(10px);
            padding: 1.25rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #1f2937;
        }
        
        .header h1 {
            color: #f8fafc;
            font-size: 1.25rem;
            font-weight: 600;
            letter-spacing: 0.2px;
        }
        
        .status {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.9rem;
            color: #9ca3af;
        }
        
        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #4ade80;
            animation: pulse 2s infinite;
        }
        
        .status-indicator.disconnected {
            background: #ef4444;
            animation: none;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 1.5rem 2rem 2.5rem;
            display: grid;
            grid-template-columns: minmax(0, 2fr) minmax(0, 1fr);
            gap: 1.75rem;
        }
        
        .main-panel {
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
        }
        
        .sidebar {
            background: #0f172a;
            border-radius: 14px;
            border: 1px solid #1f2937;
            padding: 1.25rem;
            box-shadow: 0 16px 40px rgba(0, 0, 0, 0.35);
        }
        
        .graph-container {
            background: #0f172a;
            border-radius: 14px;
            padding: 1rem 1.25rem;
            min-height: 520px;
            border: 1px solid #1f2937;
            box-shadow: 0 16px 40px rgba(0, 0, 0, 0.35);
        }
        
        #topology-graph {
            width: 100%;
            height: 100%;
            min-height: 600px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(4, minmax(0, 1fr));
            gap: 1rem;
        }
        
        .stat-card {
            background: linear-gradient(180deg, #111827 0%, #0b1222 100%);
            border: 1px solid #1f2937;
            border-radius: 14px;
            padding: 1.25rem;
            text-align: center;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.25);
        }
        
        .stat-value {
            font-size: 1.8rem;
            font-weight: 700;
            color: #f8fafc;
        }
        
        .stat-label {
            font-size: 0.85rem;
            color: #94a3b8;
            margin-top: 0.35rem;
        }
        
        .event-list {
            max-height: 520px;
            overflow-y: auto;
        }
        
        .event-item {
            background: #111827;
            border-left: 3px solid transparent;
            padding: 0.75rem 0.85rem;
            margin-bottom: 0.65rem;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .event-item:hover {
            background: #1f2937;
        }
        
        .event-item.error {
            border-left-color: #ef4444;
        }
        
        .event-item.success {
            border-left-color: #22c55e;
        }
        
        .event-item.chaos {
            border-left-color: #f59e0b;
        }
        
        .event-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.35rem;
            font-size: 0.8rem;
            color: #94a3b8;
        }
        
        .event-type {
            font-weight: 600;
            color: #93c5fd;
            text-transform: uppercase;
            letter-spacing: 0.4px;
        }
        
        .event-time {
            font-size: 0.75rem;
            color: #9ca3af;
        }
        
        .event-details {
            font-size: 0.85rem;
            color: #e2e8f0;
            margin-top: 0.2rem;
        }
        
        .detail-panel {
            background: #0b1222;
            border: 1px solid #1f2937;
            border-radius: 10px;
            padding: 0.9rem;
            margin-top: 1rem;
        }
        
        .detail-panel h3 {
            margin-bottom: 0.75rem;
            color: #93c5fd;
            font-size: 0.95rem;
        }
        
        .detail-content {
            background: #0f172a;
            border-radius: 8px;
            padding: 0.75rem;
            font-family: 'Courier New', monospace;
            font-size: 0.8rem;
            overflow-x: auto;
            max-height: 360px;
            overflow-y: auto;
        }
        
        .detail-content pre {
            margin: 0;
            color: #d1d5db;
        }
        
        .node-user { fill: #3b82f6; }
        .node-agent { fill: #8b5cf6; }
        .node-proxy { fill: #f59e0b; }
        .node-tool { fill: #10b981; }
        .node-error { fill: #ef4444; }
        .node-chaos { fill: #f59e0b; }
        
        .section-title {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 0.75rem;
            color: #e2e8f0;
        }
        
        .empty-state {
            text-align: center;
            padding: 3rem;
            color: #9ca3af;
        }
        
        .empty-state svg {
            width: 64px;
            height: 64px;
            margin: 0 auto 1rem;
            opacity: 0.5;
        }

        .toolbar {
            grid-column: 1 / -1;
            display: flex;
            gap: 0.75rem;
            align-items: center;
            margin-bottom: 0.5rem;
            flex-wrap: wrap;
            background: #0f172a;
            border: 1px solid #1f2937;
            border-radius: 12px;
            padding: 0.75rem;
        }

        .toolbar select,
        .toolbar button {
            background: #111827;
            color: #e2e8f0;
            border: 1px solid #273449;
            padding: 0.5rem 0.75rem;
            border-radius: 10px;
            font-size: 0.85rem;
        }

        .toolbar input {
            background: #111827;
            color: #e2e8f0;
            border: 1px solid #273449;
            padding: 0.5rem 0.75rem;
            border-radius: 10px;
            font-size: 0.85rem;
            min-width: 200px;
        }

        .toolbar button {
            cursor: pointer;
        }

        .toolbar button:hover {
            border-color: #60a5fa;
        }


        .status-indicator.history {
            background: #f59e0b;
        }

        .run-notice {
            grid-column: 1 / -1;
            margin: 0;
            padding: 0.75rem;
            border: 1px solid #334155;
            border-radius: 12px;
            background: #0b1222;
            color: #e2e8f0;
            display: none;
            align-items: center;
            justify-content: space-between;
        }

        .run-notice button {
            background: #111827;
            color: #e2e8f0;
            border: 1px solid #273449;
            padding: 0.5rem 0.75rem;
            border-radius: 10px;
            font-size: 0.85rem;
            cursor: pointer;
        }

        .run-notice button:hover {
            border-color: #60a5fa;
        }

        .run-summary {
            grid-column: 1 / -1;
            margin: 0;
            padding: 0.75rem;
            border: 1px solid #273449;
            border-radius: 12px;
            background: #0f172a;
            color: #e2e8f0;
            font-size: 0.85rem;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(5, minmax(0, 1fr));
            gap: 0.75rem;
            margin-top: 0.5rem;
        }

        .summary-item {
            background: #111827;
            border: 1px solid #1f2937;
            border-radius: 10px;
            padding: 0.6rem 0.75rem;
            text-align: center;
        }

        .summary-item strong {
            display: block;
            font-size: 1rem;
            margin-bottom: 0.2rem;
            color: #f8fafc;
        }

        .summary-item span {
            font-size: 0.75rem;
            color: #94a3b8;
        }

        .summary-divider {
            margin: 0.85rem 0 0.2rem;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.4px;
            color: #93c5fd;
        }

        @media (max-width: 1200px) {
            .container {
                grid-template-columns: 1fr;
            }
            .stats-grid {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }
        }

        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.5rem;
            }
            .stats-grid {
                grid-template-columns: 1fr;
            }
            .toolbar {
                flex-direction: column;
                align-items: flex-start;
            }
            .summary-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üêµ Agent Chaos Dashboard</h1>
        <div class="status">
            <div class="status-indicator" id="status-indicator"></div>
            <span id="status-text">Connecting...</span>
        </div>
    </div>
    
    <div class="container">
        <div class="toolbar">
            <label for="run-select">Mode</label>
            <select id="run-select">
                <option value="live">Live (Real-time)</option>
            </select>
            <button id="refresh-runs-btn">Refresh</button>
            <input id="event-search" type="text" placeholder="Search history events..." />
            <button id="prev-page-btn">Prev</button>
            <span id="page-info">Page 1</span>
            <button id="next-page-btn">Next</button>
        </div>
        <div class="run-notice" id="run-notice">
            <span id="run-notice-text">New run detected.</span>
            <button id="load-latest-btn">Load Latest</button>
        </div>
        <div class="run-summary" id="run-summary" style="display: none;"></div>
        <div class="main-panel">
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="stat-requests">0</div>
                    <div class="stat-label">Total Requests</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="stat-chaos">0</div>
                    <div class="stat-label">Chaos Injected</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="stat-errors">0</div>
                    <div class="stat-label">Errors</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="stat-swarm">0</div>
                    <div class="stat-label">Swarm Messages</div>
                </div>
            </div>
            
            <div class="graph-container">
                <div id="topology-graph"></div>
            </div>
        </div>
        
        <div class="sidebar">
            <div class="section-title">Recent Events</div>
            <div class="event-list" id="event-list">
                <div class="empty-state">
                    <p>Waiting for events...</p>
                </div>
            </div>
            
            <div class="detail-panel" id="detail-panel" style="display: none;">
                <h3>Request Details</h3>
                <div class="detail-content" id="detail-content"></div>
            </div>
        </div>
    </div>
    
    <script>
        // Initialize Mermaid
        mermaid.initialize({ 
            startOnLoad: false,
            theme: 'dark',
            themeVariables: {
                primaryColor: '#667eea',
                primaryTextColor: '#e0e0e0',
                primaryBorderColor: '#8b5cf6',
                lineColor: '#4ade80',
                secondaryColor: '#1a1f3a',
                tertiaryColor: '#0a0e27'
            }
        });
        
        // State
        let ws = null;
        let stats = {
            requests: 0,
            chaos: 0,
            errors: 0,
            swarm: 0
        };
        
        let nodes = new Map();
        let edges = [];
        let selectedNode = null;
        let requestData = new Map();
        let isBatching = false;
        let historyEvents = [];
        let historyPage = 1;
        const historyPageSize = 50;
        let latestRunId = null;
        let currentRunId = "live";
        
        // Initialize WebSocket connection
        function connect() {
            // Use current page's protocol and host for WebSocket
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const host = window.location.host; // e.g., "127.0.0.1:8081"
            const wsUrl = `${protocol}//${host}/ws`;
            
            console.log('Connecting to WebSocket:', wsUrl);
            ws = new WebSocket(wsUrl);
            
            ws.onopen = () => {
                updateStatus(true);
                console.log('Connected to dashboard');
            };
            
            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    handleEvent(data);
                } catch (e) {
                    console.error('Error parsing event:', e);
                }
            };
            
            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                updateStatus(false);
            };
            
            ws.onclose = () => {
                updateStatus(false);
                console.log('Disconnected, reconnecting...');
                setTimeout(connect, 3000);
            };
        }
        
        function updateStatus(connected) {
            const indicator = document.getElementById('status-indicator');
            const text = document.getElementById('status-text');
            
            if (connected) {
                indicator.classList.remove('disconnected');
                indicator.classList.remove('history');
                text.textContent = 'Connected';
            } else {
                indicator.classList.add('disconnected');
                indicator.classList.remove('history');
                text.textContent = 'Disconnected';
            }
        }

        function setHistoryStatus() {
            const indicator = document.getElementById('status-indicator');
            const text = document.getElementById('status-text');
            indicator.classList.remove('disconnected');
            indicator.classList.add('history');
            text.textContent = 'History';
        }
        
        function handleEvent(event) {
            switch (event.event_type) {
                case 'connected':
                    resetState();
                    break;
                case 'request_started':
                    handleRequestStarted(event);
                    break;
                case 'chaos_injected':
                    handleChaosInjected(event);
                    break;
                case 'response_received':
                    handleResponseReceived(event);
                    break;
                case 'swarm_message':
                    handleSwarmMessage(event);
                    break;
            }
            
            if (!isBatching) {
                addEventToList(event);
                updateStats();
                updateGraph();
            }
        }

        function resetState() {
            stats = {
                requests: 0,
                chaos: 0,
                errors: 0,
                swarm: 0
            };
            nodes = new Map();
            edges = [];
            requestData = new Map();
            historyEvents = [];
            historyPage = 1;
            const eventList = document.getElementById('event-list');
            if (eventList) {
                eventList.innerHTML = '';
            }
            const summary = document.getElementById('run-summary');
            summary.style.display = 'none';
            updateStats();
        }

        function disconnect() {
            if (ws) {
                ws.onclose = null;
                ws.close();
                ws = null;
            }
        }

        async function loadRuns() {
            try {
                const response = await fetch('/api/runs');
                const data = await response.json();
                const select = document.getElementById('run-select');
                const current = select.value;
                select.innerHTML = '<option value="live">Live (Real-time)</option>';
                for (const run of data.runs || []) {
                    if (run.has_log) {
                        const option = document.createElement('option');
                        option.value = run.id;
                        option.textContent = run.id;
                        select.appendChild(option);
                    }
                }
                if (current) {
                    select.value = current;
                }
                latestRunId = (data.runs && data.runs.length) ? data.runs[0].id : null;
                updateRunNotice();
            } catch (e) {
                console.error('Failed to load runs:', e);
            }
        }

        async function loadHistory(runId) {
            resetState();
            disconnect();
            setHistoryStatus();
            currentRunId = runId;
            try {
                await loadRunSummary(runId);
                const response = await fetch(`/api/runs/${runId}/events`);
                const data = await response.json();
                const events = data.events || [];
                historyEvents = events;
                isBatching = true;
                for (const event of events) {
                    handleEvent(event);
                }
                isBatching = false;
                updateStats();
                updateGraph();
                renderHistoryEvents();
            } catch (e) {
                console.error('Failed to load run history:', e);
            }
        }

        function switchToLive() {
            resetState();
            connect();
            currentRunId = "live";
            updateStatus(true);
        }

        async function loadRunSummary(runId) {
            try {
                const response = await fetch(`/api/runs/${runId}/summary`);
                const summary = await response.json();
                const summaryDiv = document.getElementById('run-summary');
                summaryDiv.style.display = 'block';
                    const agent = summary.agent_metrics || {};
                    const hasAgentMetrics = Object.keys(agent).length > 0;
                summaryDiv.innerHTML = `
                    <strong>Run Summary</strong>
                    <div class="summary-grid">
                        <div class="summary-item">
                            <strong>${summary.total_requests || 0}</strong>
                            <span>Total Requests</span>
                        </div>
                        <div class="summary-item">
                            <strong>${summary.error_requests || 0}</strong>
                            <span>Errors (${((summary.error_rate || 0) * 100).toFixed(1)}%)</span>
                        </div>
                        <div class="summary-item">
                            <strong>${summary.chaos_injections || 0}</strong>
                            <span>Chaos Injections</span>
                        </div>
                        <div class="summary-item">
                            <strong>${((summary.success_rate || 0) * 100).toFixed(1)}%</strong>
                            <span>Success Rate</span>
                        </div>
                        <div class="summary-item">
                            <strong>${((summary.chaos_hit_rate || 0) * 100).toFixed(1)}%</strong>
                            <span>Chaos Hit Rate</span>
                        </div>
                        <div class="summary-item">
                            <strong>${summary.input_validation_errors || 0}</strong>
                            <span>Input Errors (${((summary.input_error_rate || 0) * 100).toFixed(1)}%)</span>
                        </div>
                        <div class="summary-item">
                            <strong>${summary.tool_requests || 0}</strong>
                            <span>Proxy Tool Calls</span>
                        </div>
                        <div class="summary-item">
                            <strong>${summary.tool_errors || 0}</strong>
                            <span>Proxy Tool Errors (${((summary.tool_error_rate || 0) * 100).toFixed(1)}%)</span>
                        </div>
                        <div class="summary-item">
                            <strong>${summary.llm_requests || 0}</strong>
                            <span>Proxy LLM Calls</span>
                        </div>
                        <div class="summary-item">
                            <strong>${summary.llm_errors || 0}</strong>
                            <span>Proxy LLM Errors (${((summary.llm_error_rate || 0) * 100).toFixed(1)}%)</span>
                        </div>
                    </div>
                    ${hasAgentMetrics ? `
                    <div class="summary-divider">Agent Reliability</div>
                    <div class="summary-grid">
                        <div class="summary-item">
                            <strong>${agent.tool_calls || 0}</strong>
                            <span>Agent Tool Calls</span>
                        </div>
                        <div class="summary-item">
                            <strong>${agent.tool_success || 0}</strong>
                            <span>Agent Tool Success</span>
                        </div>
                        <div class="summary-item">
                            <strong>${agent.tool_errors || 0}</strong>
                            <span>Agent Tool Errors</span>
                        </div>
                        <div class="summary-item">
                            <strong>${agent.validation_errors || 0}</strong>
                            <span>Validation Errors</span>
                        </div>
                        <div class="summary-item">
                            <strong>${agent.validation_fixed || 0}</strong>
                            <span>Validation Fixed</span>
                        </div>
                        <div class="summary-item">
                            <strong>${agent.retries || 0}</strong>
                            <span>Retries</span>
                        </div>
                        <div class="summary-item">
                            <strong>${agent.retries_success || 0}</strong>
                            <span>Retry Success</span>
                        </div>
                        <div class="summary-item">
                            <strong>${agent.llm_corrections || 0}</strong>
                            <span>LLM Corrections</span>
                        </div>
                        <div class="summary-item">
                            <strong>${agent.llm_correction_success || 0}</strong>
                            <span>LLM Correction Success</span>
                        </div>
                    </div>
                    ` : ""}
                `;
            } catch (e) {
                console.error('Failed to load run summary:', e);
            }
        }

        function renderHistoryEvents() {
            const eventList = document.getElementById('event-list');
            eventList.innerHTML = '';
            const searchValue = document.getElementById('event-search').value.toLowerCase();
            const filtered = historyEvents.filter((event) => {
                const haystack = JSON.stringify(event).toLowerCase();
                return haystack.includes(searchValue);
            });
            const totalPages = Math.max(1, Math.ceil(filtered.length / historyPageSize));
            historyPage = Math.min(historyPage, totalPages);
            const start = (historyPage - 1) * historyPageSize;
            const pageEvents = filtered.slice(start, start + historyPageSize);
            if (pageEvents.length === 0) {
                eventList.innerHTML = '<div class="empty-state"><p>No events found.</p></div>';
            } else {
                for (const ev of pageEvents) {
                    addEventToList(ev);
                }
            }
            document.getElementById('page-info').textContent = `Page ${historyPage} / ${totalPages}`;
        }

        function updateRunNotice() {
            const notice = document.getElementById('run-notice');
            const text = document.getElementById('run-notice-text');
            if (latestRunId && currentRunId !== latestRunId) {
                text.textContent = `New run detected: ${latestRunId}`;
                notice.style.display = 'flex';
            } else {
                notice.style.display = 'none';
            }
        }
        
        function handleRequestStarted(event) {
            stats.requests++;
            const requestId = event.request_id;
            
            // Store request data
            requestData.set(requestId, {
                method: event.method,
                url: event.url,
                agent_role: event.agent_role,
                traffic_type: event.traffic_type,
                timestamp: event.timestamp
            });
            
            // Add nodes
            if (!nodes.has('user')) {
                nodes.set('user', { id: 'user', label: 'User', type: 'user' });
            }
            
            if (!nodes.has('agent')) {
                nodes.set('agent', { 
                    id: 'agent', 
                    label: event.agent_role || 'Agent', 
                    type: 'agent' 
                });
            }
            
            const toolId = extractToolId(event.url);
            if (toolId && !nodes.has(toolId)) {
                nodes.set(toolId, { 
                    id: toolId, 
                    label: toolId, 
                    type: 'tool' 
                });
            }
            
            if (!nodes.has('proxy')) {
                nodes.set('proxy', { 
                    id: 'proxy', 
                    label: 'Chaos Proxy', 
                    type: 'proxy' 
                });
            }
        }
        
        function handleChaosInjected(event) {
            stats.chaos++;
            const node = nodes.get('proxy');
            if (node) {
                node.chaos = true;
                node.chaosStrategy = event.strategy_name;
            }
        }
        
        function handleResponseReceived(event) {
            const requestId = event.request_id;
            const data = requestData.get(requestId);
            
            if (data) {
                data.status_code = event.status_code;
                data.success = event.success;
                data.latency_ms = event.latency_ms;
            }
            
            const isError = (typeof event.status_code === 'number' && event.status_code >= 400) || event.success === false;
            if (isError) {
                stats.errors++;
                const node = nodes.get('proxy');
                if (node) {
                    node.error = true;
                }
            }
        }
        
        function handleSwarmMessage(event) {
            stats.swarm++;
            // Add swarm-specific nodes
            if (event.from_agent && !nodes.has(`agent-${event.from_agent}`)) {
                nodes.set(`agent-${event.from_agent}`, {
                    id: `agent-${event.from_agent}`,
                    label: event.from_agent,
                    type: 'agent'
                });
            }
            
            if (event.to_agent && !nodes.has(`agent-${event.to_agent}`)) {
                nodes.set(`agent-${event.to_agent}`, {
                    id: `agent-${event.to_agent}`,
                    label: event.to_agent,
                    type: 'agent'
                });
            }
        }
        
        function extractToolId(url) {
            // Extract tool name from URL
            const match = url.match(/\/([^\/]+)(?:\?|$)/);
            return match ? match[1] : null;
        }
        
        function updateStats() {
            document.getElementById('stat-requests').textContent = stats.requests;
            document.getElementById('stat-chaos').textContent = stats.chaos;
            document.getElementById('stat-errors').textContent = stats.errors;
            document.getElementById('stat-swarm').textContent = stats.swarm;
        }
        
        function updateGraph() {
            // Build Mermaid graph
            let graphDef = 'graph TD\n';
            
            // Add nodes with styling
            for (const [id, node] of nodes.entries()) {
                let style = '';
                if (node.error) {
                    style = ':::error';
                } else if (node.chaos) {
                    style = ':::chaos';
                } else {
                    style = `:::${node.type}`;
                }
                
                graphDef += `    ${id}["${node.label}"]${style}\n`;
            }
            
            // Add edges
            if (nodes.has('user') && nodes.has('agent')) {
                graphDef += '    user --> agent\n';
            }
            if (nodes.has('agent') && nodes.has('proxy')) {
                graphDef += '    agent --> proxy\n';
            }
            if (nodes.has('proxy')) {
                for (const [id, node] of nodes.entries()) {
                    if (node.type === 'tool') {
                        graphDef += `    proxy --> ${id}\n`;
                    }
                }
            }
            
            // Add custom styles
            graphDef += `
    classDef user fill:#3b82f6,stroke:#1e40af,stroke-width:2px,color:#fff
    classDef agent fill:#8b5cf6,stroke:#6d28d9,stroke-width:2px,color:#fff
    classDef proxy fill:#f59e0b,stroke:#d97706,stroke-width:2px,color:#fff
    classDef tool fill:#10b981,stroke:#059669,stroke-width:2px,color:#fff
    classDef error fill:#ef4444,stroke:#dc2626,stroke-width:2px,color:#fff
    classDef chaos fill:#f59e0b,stroke:#d97706,stroke-width:3px,color:#fff
`;
            
            // Render graph
            const graphDiv = document.getElementById('topology-graph');
            graphDiv.innerHTML = '';
            
            mermaid.render('topology-graph-svg', graphDef, (svgCode) => {
                graphDiv.innerHTML = svgCode;
                
                // Add click handlers to nodes
                setTimeout(() => {
                    const svg = graphDiv.querySelector('svg');
                    if (svg) {
                        const nodeElements = svg.querySelectorAll('g.node');
                        nodeElements.forEach((el, idx) => {
                            el.style.cursor = 'pointer';
                            el.addEventListener('click', () => {
                                const nodeId = Array.from(nodes.keys())[idx];
                                showNodeDetails(nodeId);
                            });
                        });
                    }
                }, 100);
            });
        }
        
        function addEventToList(event) {
            const eventList = document.getElementById('event-list');
            
            // Remove empty state
            const emptyState = eventList.querySelector('.empty-state');
            if (emptyState) {
                emptyState.remove();
            }
            
            const eventItem = document.createElement('div');
            eventItem.className = 'event-item';
            
            // Add class based on event type
            if (event.event_type === 'response_received' && !event.success) {
                eventItem.classList.add('error');
            } else if (event.event_type === 'response_received' && event.success) {
                eventItem.classList.add('success');
            } else if (event.event_type === 'chaos_injected') {
                eventItem.classList.add('chaos');
            }
            
            const time = new Date(event.timestamp).toLocaleTimeString();
            const typeLabel = event.event_type.replace('_', ' ').toUpperCase();
            
            eventItem.innerHTML = `
                <div class="event-header">
                    <span class="event-type">${typeLabel}</span>
                    <span class="event-time">${time}</span>
                </div>
                <div class="event-details">
                    ${getEventDetails(event)}
                </div>
            `;
            
            eventItem.addEventListener('click', () => {
                showEventDetails(event);
            });
            
            eventList.insertBefore(eventItem, eventList.firstChild);
            
            // Keep only last 50 events
            while (eventList.children.length > 50) {
                eventList.removeChild(eventList.lastChild);
            }
        }
        
        function getEventDetails(event) {
            switch (event.event_type) {
                case 'request_started':
                    return `${event.method} ${event.url.substring(0, 50)}...`;
                case 'chaos_injected':
                    return `Strategy: ${event.strategy_name} (${event.phase})`;
                case 'response_received':
                    return `Status: ${event.status_code} ${event.success ? '‚úì' : '‚úó'}`;
                case 'swarm_message':
                    return `${event.from_agent || '?'} ‚Üí ${event.to_agent || '?'}`;
                default:
                    return JSON.stringify(event, null, 2);
            }
        }
        
        function showNodeDetails(nodeId) {
            const node = nodes.get(nodeId);
            if (!node) return;
            
            const panel = document.getElementById('detail-panel');
            const content = document.getElementById('detail-content');
            
            panel.style.display = 'block';
            content.innerHTML = `<pre>${JSON.stringify(node, null, 2)}</pre>`;
        }
        
        function showEventDetails(event) {
            const panel = document.getElementById('detail-panel');
            const content = document.getElementById('detail-content');
            
            panel.style.display = 'block';
            
            // Redact sensitive data
            const redacted = { ...event };
            if (redacted.url) {
                redacted.url = redacted.url.replace(/api[_-]?key=[^&]*/gi, 'api_key=[REDACTED]');
                redacted.url = redacted.url.replace(/token=[^&]*/gi, 'token=[REDACTED]');
            }
            
            content.innerHTML = `<pre>${JSON.stringify(redacted, null, 2)}</pre>`;
        }
        
        // Initialize
        document.getElementById('refresh-runs-btn').addEventListener('click', async () => {
            await loadRuns();
        });

        document.getElementById('run-select').addEventListener('change', async (event) => {
            const selected = event.target.value;
            if (selected === 'live') {
                switchToLive();
                return;
            }
            await loadHistory(selected);
        });

        document.getElementById('event-search').addEventListener('input', () => {
            historyPage = 1;
            renderHistoryEvents();
        });

        document.getElementById('prev-page-btn').addEventListener('click', () => {
            if (historyPage > 1) {
                historyPage -= 1;
                renderHistoryEvents();
            }
        });

        document.getElementById('next-page-btn').addEventListener('click', () => {
            historyPage += 1;
            renderHistoryEvents();
        });

        document.getElementById('load-latest-btn').addEventListener('click', async () => {
            if (!latestRunId) return;
            const select = document.getElementById('run-select');
            select.value = latestRunId;
            await loadHistory(latestRunId);
        });

        loadRuns();
        switchToLive();
        updateGraph();
        setInterval(loadRuns, 10000);
    </script>
</body>
</html>

