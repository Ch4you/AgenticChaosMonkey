# RAG Poisoning Strategy

## Overview

The RAG (Retrieval-Augmented Generation) Poisoning strategy allows you to inject false information into vector database responses to test agent resilience against misinformation and hallucinations.

## Architecture

### ResponseMutationStrategy (Base Class)

A specialized base class for strategies that modify HTTP response bodies:

- **Async Processing**: Fully async to handle high concurrency
- **Compression Handling**: Transparently handles Gzip and Brotli compression
- **Memory Efficient**: Limits body size to prevent memory issues (default: 10MB)
- **JSON Support**: Only processes JSON responses

### PhantomDocumentStrategy

Implements RAG poisoning using JSONPath to target specific fields in responses:

- **JSONPath Targeting**: Uses `jsonpath-ng` to locate text fields
- **Two Modes**:
  - `overwrite`: Replace text with fake information
  - `injection`: Append conflicting information to existing text
- **Configurable Data Source**: Load misinformation from JSON file or inline list
- **Probability Control**: Configurable probability of applying the attack

## Usage

### Basic Configuration

```yaml
scenarios:
  - name: "poison_pinecone"
    type: "phantom_document"
    target_ref: "pinecone_api"
    enabled: true
    probability: 0.5
    params:
      target_json_path: "$.matches[*].metadata.text"
      mode: "overwrite"
      misinformation_source: "examples/misinformation.json"
```

### JSONPath Examples

**Pinecone:**
```text
$.matches[*].metadata.text
```

**Weaviate:**
```text
$.data.Get.Document[*].content
```

**Custom Search API:**
```text
$.results[*].snippet
```

### Misinformation Source

**From File:**
```yaml
misinformation_source: "examples/misinformation.json"
```

**Inline List:**
```yaml
misinformation_source:
  - "FAKE: This is false information."
  - "CONFLICTING: This contradicts the original."
```

**Default:**
If not specified, uses built-in default misinformation examples.

## Implementation Details

### Compression Handling

The strategy automatically:
1. Detects compression from `Content-Encoding` header
2. Decompresses response body (Gzip/Brotli)
3. Applies mutation
4. Re-compresses with same encoding
5. Updates `Content-Length` header

### Performance

- **Async**: Non-blocking operations using `async/await`
- **Memory Limits**: Skips responses > 10MB (configurable)
- **Efficient Parsing**: Uses streaming JSON parsing where possible

### Error Handling

- Gracefully handles missing JSONPath matches
- Skips non-string values
- Logs warnings for invalid JSONPath expressions
- Falls back to uncompressed if compression fails

## Testing

See `tests/unit/test_rag_strategy.py` for comprehensive test coverage including:
- Overwrite and injection modes
- Gzip compression handling
- Various JSONPath expressions
- Probability control
- Error cases

## Example Response Mutation

**Before:**
```json
{
  "matches": [
    {
      "metadata": {
        "text": "The capital of France is Paris."
      }
    }
  ]
}
```

**After (overwrite mode):**
```json
{
  "matches": [
    {
      "metadata": {
        "text": "The Earth is flat and NASA has been covering this up for decades."
      }
    }
  ]
}
```

**After (injection mode):**
```json
{
  "matches": [
    {
      "metadata": {
        "text": "The capital of France is Paris.\n\n[CONFLICTING INFO] The Earth is flat and NASA has been covering this up for decades."
      }
    }
  ]
}
```

## Integration

The strategy is automatically registered in `StrategyFactory` and can be used in chaos plans:

```yaml
targets:
  - name: "vector_db"
    type: "http_endpoint"
    pattern: ".*pinecone.*|.*weaviate.*"

scenarios:
  - name: "rag_poison"
    type: "phantom_document"
    target_ref: "vector_db"
    params:
      target_json_path: "$.matches[*].metadata.text"
      mode: "overwrite"
```

## Dependencies

- `jsonpath-ng>=1.6.0`: For JSONPath expression parsing
- `gzip`, `brotli`: Standard library compression support

